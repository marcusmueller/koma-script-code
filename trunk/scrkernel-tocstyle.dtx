% \CheckSum{889}
% \iffalse meta-comment
% ======================================================================
% scrkernel-tocstyle.dtx
% Copyright (c) Markus Kohm, 2015
%
% This file is part of the LaTeX2e KOMA-Script bundle.
%
% This work may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, version 1.3c of the license.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3c or later is part of all distributions of LaTeX 
% version 2005/12/01 or later and of this work.
%
% This work has the LPPL maintenance status "author-maintained".
%
% The Current Maintainer and author of this work is Markus Kohm.
%
% This work consists of all files listed in manifest.txt.
% ----------------------------------------------------------------------
% scrkernel-tocstyle.dtx
% Copyright (c) Markus Kohm, 2015
%
% Dieses Werk darf nach den Bedingungen der LaTeX Project Public Lizenz,
% Version 1.3c, verteilt und/oder veraendert werden.
% Die neuste Version dieser Lizenz ist
%   http://www.latex-project.org/lppl.txt
% und Version 1.3c ist Teil aller Verteilungen von LaTeX
% Version 2005/12/01 oder spaeter und dieses Werks.
%
% Dieses Werk hat den LPPL-Verwaltungs-Status "author-maintained"
% (allein durch den Autor verwaltet).
%
% Der Aktuelle Verwalter und Autor dieses Werkes ist Markus Kohm.
% 
% Dieses Werk besteht aus den in manifest.txt aufgefuehrten Dateien.
% ======================================================================
% \fi
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
% \iffalse
%%% From File: $Id: scrkernel-tocstyle.dtx 2254 2015-11-12 09:31:08Z kohm $
% The runs of run-time file generation:
%<preidentify>%%%            (run: preidentify)
% - everything that is needed before selfidentification of resulting files
%   (unused)
%<identify>%%%            (run: identify)
% - everything that is needed for selfidentification of resulting files
%   (unused)
%<prepare>%%%            (run: prepare)
% - everything that is needed to define options
%<option>%%%            (run: option)
% - definition of options (unused)
%<execoption>%%%            (run: execoption)
% - initial option executions up to \KOMAProcessOptions 
%   (unused)
%<body>%%%            (run: body)
% - everything, that should be done after \KOMAProcessOptions
%<exit>%%%            (run: exit)
% - everything, that should be done immediately before leaving the file
%   (unused) 
%<*driver>
% \fi
\ifx\ProvidesFile\undefined\def\ProvidesFile#1[#2]{}\fi
\begingroup
  \def\filedate$#1: #2-#3-#4 #5${\gdef\filedate{#2/#3/#4}}
  \filedate$Date: 2015-11-12 10:31:08 +0100 (Do, 12. Nov 2015) $
  \def\filerevision$#1: #2 ${\gdef\filerevision{#2}}
  \filerevision$Revision: 2254 $
  \edef\reserved@a{%
    \noexpand\endgroup
    \noexpand\ProvidesFile{scrkernel-tocstyle.dtx}%
                          [\filedate\space\filerevision\space
                           KOMA-Script (TOC styles)]
  }%
\reserved@a
% \iffalse
\documentclass[halfparskip-]{scrdoc}
\usepackage[english,ngerman]{babel}
\usepackage[latin1]{inputenc}
\CodelineIndex
\RecordChanges
\GetFileInfo{scrkernel-tocstyle.dtx}
\title{\KOMAScript{} \partname\ \texttt{\filename}%
  \footnote{Dies ist Version \fileversion\ von Datei
    \texttt{\filename}.}}
\date{\filedate}
\author{Markus Kohm}

\begin{document}
  \maketitle
  \tableofcontents
  \DocInput{\filename}
\end{document}
%</driver>
% \fi
%
% \selectlanguage{ngerman}
%
% \section{Verzeichnisstile}
%
% Verzeichnisstile werden derzeit nur in Kooperation mit Gliederungsstilen
% untersützt. In Zukunft soll das aber mal anders werden. Dann sollen
% Verzeichnisstile Teil der Grundfunktionalität für Verzeichnisse (Paket
% \textsf{tocbasic}) werden und auch unabhängig von Gliederungsstilen
% einsetzbar sein.
%
% \StopEventually{\PrintIndex\PrintChanges}
%
% \changes{v3.20}{2015/11/13}{neu und nur bei Vorhandensein verwendet}
%
%
% \subsection{Grundlagen für Verzeichniseintragsstile}
%
% \emph{Hinweis: Dieser Code wird möglicherweise später in \textsf{tocbasic}
% wandern. Das ist aber erst möglich, wenn die Verwendung der hier
% deklarierten Optionen innerhalb \cs{DeclareSectionCommand} implementiert
% ist und eine Verwendung zusammen mit beispielsweise den Standardklassen
% möglich ist.}
%
% Ab \KOMAScript~3.20 halten Stile Einzug in die Verzeichnisse. Der erste
% Schritt dabei sind die Stile der Verzeichniseinträge. Jeder Stil besteht aus
% einer Anweisung, mit der ein Verzeichnisbefehl definiert wird und
% zugehörigen Optionen. Die Optionen dienen dazu, Einstellungen für die
% einzelnen Verzeichnisbefehle vorzunehmen.
%
% \begin{macro}{\scrkernel@tocstyle@available}
% Diese Anweisung wird nur solange definiert werden, so lange dieses Modul von
% \KOMAScript{} optional ist. Andere Module können darüber erkennen, ob sie
% das Modul bereits verwenden können oder nicht.
%    \begin{macrocode}
%<prepare>\newcommand*{\scrkernel@tocstyle@available}{}
%    \end{macrocode}
% \end{macro}
%
% \changes{v3.20}{2015/11/17}{Verzeichnisstile bekommen das
%   \texttt{KOMAarg}-Mitglied \texttt{.dte}}^^A
%    \begin{macrocode}
%<*body>
\DefineFamily{KOMAarg}
\DefineFamilyMember[.dte]{KOMAarg}
%</body>
%    \end{macrocode}
%
% \begin{macro}{\DefineTOCEntryOption}
%   \changes{v3.20}{2015/11/10}{neu}
% Die Definition der Optionen geschieht mit einer einheitlichen
% Schnittstelle. Wichtig dabei ist, dass hier nicht tatsächlich die Optionen
% definiert werden, sondern eine Anweisung, die ihrerseits die Optionen bei
% Bedarf definiert. Ein solcher Bedarf besteht beispielsweise bei der
% Definition des Eintragsbefehls selbst. Er besteht aber auch innerhalb von
% \cs{DeclareSectionCommand}, weil diese Anweisung ebenfalls indirekt
% Verzeichniseinträge definiert und deshalb die Optionen auswerten können
% soll. Es gibt folgende Parameter:
% \begin{description}
% \item[\marg{Stil}: \meta{String},] Name des Eintragsstils
% \item[\marg{Option}: \meta{String},] Name der Option
% \item[\oarg{Wert}:] der Säumniswert der Option abhängig von der
%   \meta{Definition}
% \item[\marg{Definition}: \meta{Code},] Definition der Option
% \item[\oarg{Init}: \meta{Code},] Initialisierung der Option
% \end{description}
% \begin{macro}{\@DefineTOCEntryOptionWithoutDefault}
%   \changes{v3.20}{2015/11/10}{neu (intern)}
% \begin{macro}{\@DefineTOCEntryOptionWithDefault}
%   \changes{v3.20}{2015/11/10}{neu (intern)}
% Da mit einem optionalen Argument an Position 3 gearbeitet wird, werden zwei
% Hilfsmakros benötigt.
%    \begin{macrocode}
%<*body>
\newcommand*{\DefineTOCEntryOption}[2]{%
  \scr@ifundefinedorrelax{scr@dte@#1@doopts}{%
    \@namedef{scr@dte@#1@doopts}{}}{}%
  \scr@ifundefinedorrelax{scr@dte@#1@defopts}{%
    \@namedef{scr@dte@#1@defopts}{}}{}%
  \scr@ifundefinedorrelax{scr@dte@#1@relaxopts}{%
    \@namedef{scr@dte@#1@relaxopts}{}}{}%
  \@ifnextchar [%]
    {\@DefineTOCEntryOptionWithDefault{#1}{#2}}%
    {\@DefineTOCEntryOptionWithoutDefault{#1}{#2}}%
}
\newcommand*{\@DefineTOCEntryOptionWithoutDefault}[3]{%
  \expandafter\l@addto@macro\csname scr@dte@#1@defopts\endcsname{%
    \DefineFamilyKey[.dte]{KOMAarg}{#2}{#3}%
  }%
  \expandafter\l@addto@macro\csname scr@dte@#1@relaxopts\endcsname{%
    \RelaxFamilyKey[.dte]{KOMAarg}{#2}%
  }%
  \expandafter\l@addto@macro\csname scr@dte@#1@doopts\endcsname{\do{#2}}%
  \@ifnextchar [%]
    {\scr@dte@add@optional@initcode{#1}}%
    {}%
}
\newcommand*{\@DefineTOCEntryOptionWithDefault}{}
\def\@DefineTOCEntryOptionWithDefault#1#2[#3]#4{%
  \expandafter\l@addto@macro\csname scr@dte@#1@defopts\endcsname{%
    \DefineFamilyKey[.dte]{KOMAarg}{#2}[{#3}]{#4}%
  }%
  \expandafter\l@addto@macro\csname scr@dte@#1@relaxopts\endcsname{%
    \RelaxFamilyKey[.dte]{KOMAarg}{#2}%
  }%
  \expandafter\l@addto@macro\csname scr@dte@#1@doopts\endcsname{\do[{#3}]{#2}}%
  \@ifnextchar [%]
    {\scr@dte@add@optional@initcode{#1}}%
    {}%
}
%    \end{macrocode}
% \begin{macro}{\scr@dte@add@optional@initcode}
%   \changes{v3.20}{2015/11/19}{neu (intern)}
% Macht aus einem zweiten optionalen Argument ein obligatorisches Argument für
% den Aufruf von \cs{TOCStyleInitCode}.
%    \begin{macrocode}
\newcommand*{\scr@dte@add@optional@initcode}{}
\long\def\scr@dte@add@optional@initcode#1[#2]{%
  \TOCStyleInitCode{#1}{#2}%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \scr@dte@add@optional@initcode
% \end{macro}^^A \@DefineTOCEntryOptionWithoutDefault
% \end{macro}^^A \@DefineTOCEntryOptionWithDefault
% \end{macro}^^A \DefineTOCEntryOption
%
% \begin{macro}{\DefineTOCEntryLengthOption}
%   \changes{v3.20}{2015/11/10}{neu}
% Verwendet \cs{DefineTOCEntryOption}, um eine Option zu definieren, die ein
% Längenmacro definiert. Es gibt folgende Parameter:
% \begin{description}
% \item[\marg{Stil}: \meta{String},] Name des Eintragsstils
% \item[\marg{Option}: \meta{String},] Name der Option
% \item[\oarg{Wert}:] der Säumniswert der Option
% \item[\marg{Prefix}: \meta{String},] Präfix des zu definierenden Makros
% \item[\marg{Postfix}: \meta{String},] Postfix des zu definierenden Makros
% \item[\marg{Erklärung}: \meta{String},] Erklärung der Option
% \item[\oarg{Init}: \meta{Code},] Initialisierung der Option
% \end{description}
% Zwischen Prefix und Postfix wird bei der späteren, tatsächlichen Definition
% automatisch \cs{scr@dte@current} eingefügt.
% \begin{macro}{\@DefineTOCEntryLengthOptionWithoutDefault}
%   \changes{v3.20}{2015/11/10}{neu (intern)}^^A
% \begin{macro}{\@DefineTOCEntryLengthOptionWithDefault}
%   \changes{v3.20}{2015/11/10}{neu (intern)}^^A
% \begin{macro}{\@DefineTOCEntryLengthOptionMacro}
%   \changes{v3.20}{2015/11/10}{neu (intern)}^^A
% Da mit einem optionalen Argument an Position 3 gearbeitet wird, werden drei
% Hilfsmakros benötigt.
%    \begin{macrocode}
%<*body>
\newcommand*{\DefineTOCEntryLengthOption}[2]{%
  \@ifnextchar [%]
    {\@DefineTOCEntryLengthOptionWithDefault{#1}{#2}}
    {\@DefineTOCEntryLengthOptionWithoutDefault{#1}{#2}}%
}
\newcommand*{\@DefineTOCEntryLengthOptionWithoutDefault}[5]{%
  \TOCStyleNeedsCommandByOption{#1}{#3}{#4}{#2}{#5}%
  \DefineTOCEntryOption{#1}{#2}{%
    \@DefineTOCEntryLengthOptionMacro{#2}{#3}{#4}{##1}%
  }%
}
\newcommand*{\@DefineTOCEntryLengthOptionWithDefault}{}
\def\@DefineTOCEntryLengthOptionWithDefault#1#2[#3]#4#5#6{%
  \TOCStyleNeedsCommandByOption{#1}{#4}{#5}{#2}{#6}%
  \DefineTOCEntryOption{#1}{#2}[{#3}]{%
    \@DefineTOCEntryLengthOptionMacro{#2}{#4}{#5}{##1}%
  }%
}
\newcommand*{\@DefineTOCEntryLengthOptionMacro}[4]{%
  \FamilySetLength{KOMAarg}{#1}{\@tempskipa}{#4}%
  \ifx\FamilyKeyState\FamilyKeyStateProcessed
    \ifscr@dte@expandtopt
      \expandafter\edef\csname #2\scr@dte@current#3\endcsname{%
        \the\@tempskipa}%
    \else
      \expandafter\edef\csname #2\scr@dte@current#3\endcsname{#4}%
    \fi
  \fi
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@DefineTOCEntryLengthOptionMacro
% \end{macro}^^A \@DefineTOCEntryLengthOptionWithDefault
% \end{macro}^^A \@DefineTOCEntryLengthOptionWithoutDefault
% \end{macro}^^A \DefineTOCEntryLengthOption
%
% \begin{macro}{\DefineTOCEntryNumberOption}
%   \changes{v3.20}{2015/11/12}{neu}
% Verwendet \cs{DefineTOCEntryOption}, um eine Option zu definieren, die ein
% Nummernmacro definiert. Es gibt folgende Parameter:
% \begin{description}
% \item[\marg{Stil}: \meta{String},] Name des Eintragsstils
% \item[\marg{Option}: \meta{String},] Name der Option
% \item[\oarg{Wert}:] der Säumniswert der Option
% \item[\marg{Prefix}: \meta{String},] Präfix des zu definierenden Makros
% \item[\marg{Postfix}: \meta{String},] Postfix des zu definierenden Makros
% \item[\marg{Erklärung}: \meta{String},] Erklärung der Option
% \item[\oarg{Init}: \meta{Code},] Initialisierung der Option
% \end{description}
% Zwischen Prefix und Postfix wird bei der späteren, tatsächlichen Definition
% automatisch \cs{scr@dte@current} eingefügt.
% \begin{macro}{\@DefineTOCEntryNumberOptionWithoutDefault}
%   \changes{v3.20}{2015/11/12}{neu (intern)}
% \begin{macro}{\@DefineTOCEntryNumberOptionWithDefault}
%   \changes{v3.20}{2015/11/12}{neu (intern)}
% \begin{macro}{\@DefineTOCEntryNumberOptionMacro}
%   \changes{v3.20}{2015/11/12}{neu (intern)}
% Da mit einem optionalen Argument an Position 3 gearbeitet wird, werden drei
% Hilfsmakros benötigt.
%    \begin{macrocode}
%<*body>
\newcommand*{\DefineTOCEntryNumberOption}[2]{%
  \@ifnextchar [%]
    {\@DefineTOCEntryNumberOptionWithDefault{#1}{#2}}
    {\@DefineTOCEntryNumberOptionWithoutDefault{#1}{#2}}%
}
\newcommand*{\@DefineTOCEntryNumberOptionWithoutDefault}[5]{%
  \TOCStyleNeedsCommandByOption{#1}{#3}{#4}{#2}{#5}%
  \DefineTOCEntryOption{#1}{#2}{%
    \@DefineTOCEntryNumberOptionMacro{#2}{#3}{#4}{##1}%
  }%
}
\newcommand*{\@DefineTOCEntryNumberOptionWithDefault}{}
\def\@DefineTOCEntryNumberOptionWithDefault#1#2[#3]#4#5#6{%
  \TOCStyleNeedsCommandByOption{#1}{#4}{#5}{#2}{#6}%
  \DefineTOCEntryOption{#1}{#2}[{#3}]{%
    \@DefineTOCEntryNumberOptionMacro{#2}{#4}{#5}{##1}%
  }%
}
\newcommand*{\@DefineTOCEntryNumberOptionMacro}[4]{%
  \edef\reserved@a{%
    \noexpand\FamilySetCounterMacro{KOMAarg}{#1}{%
      \expandafter\noexpand\csname #2\scr@dte@current#3\endcsname
    }{#4}%
  }\reserved@a
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@DefineTOCEntryNumberOptionMacro
% \end{macro}^^A \@DefineTOCEntryNumberOptionWithDefault
% \end{macro}^^A \@DefineTOCEntryNumberOptionWithoutDefault
% \end{macro}^^A \DefineTOCEntryNumberOption
%
% \begin{macro}{\DefineTOCEntryBoolOption}
%   \changes{v3.20}{2015/11/17}{neu}
% Verwendet \cs{DefineTOCEntryOption}, um eine Option zu definieren, die einen
% Schalter definiert. Es gibt folgende Parameter:
% \begin{description}
% \item[\marg{Stil}: \meta{String},] Name des Eintragsstils
% \item[\marg{Option}: \meta{String},] Name der Option
% \item[\oarg{Wert}:] der Säumniswert der Option
% \item[\marg{Prefix}: \meta{String},] Präfix des zu definierenden Makros
% \item[\marg{Postfix}: \meta{String},] Postfix des zu definierenden Makros
% \item[\marg{Erklärung}: \meta{String},] Erklärung der Option
% \item[\oarg{Init}: \meta{Code},] Initialisierung der Option
% \end{description}
% Zwischen Prefix und Postfix wird bei der späteren, tatsächlichen Definition
% automatisch \cs{scr@dte@current} eingefügt.
% \begin{macro}{\@DefineTOCEntryBoolOptionWithoutDefault}
%   \changes{v3.20}{2015/11/12}{neu (intern)}
% \begin{macro}{\@DefineTOCEntryBoolOptionWithDefault}
%   \changes{v3.20}{2015/11/12}{neu (intern)}
% \begin{macro}{\@DefineTOCEntryBoolOptionMacro}
%   \changes{v3.20}{2015/11/12}{neu (intern)}
% Da mit einem optionalen Argument an Position 3 gearbeitet wird, werden drei
% Hilfsmakros benötigt.
%    \begin{macrocode}
%<*body>
\newcommand*{\DefineTOCEntryBoolOption}[2]{%
  \@ifnextchar [%]
    {\@DefineTOCEntryBoolOptionWithDefault{#1}{#2}}
    {\@DefineTOCEntryBoolOptionWithoutDefault{#1}{#2}}%
}
\newcommand*{\@DefineTOCEntryBoolOptionWithoutDefault}[5]{%
  \TOCStyleNeedsCommandByOption{#1}{if#3}{#4}{#2}{#5}%
  \DefineTOCEntryOption{#1}{#2}{%
    \@DefineTOCEntryBoolOptionMacro{#2}{#3}{#4}{##1}%
  }%
}
\newcommand*{\@DefineTOCEntryBoolOptionWithDefault}{}
\def\@DefineTOCEntryBoolOptionWithDefault#1#2[#3]#4#5#6{%
  \TOCStyleNeedsCommandByOption{#1}{if#4}{#5}{#2}{#6}%
  \DefineTOCEntryOption{#1}{#2}[{#3}]{%
    \@DefineTOCEntryBoolOptionMacro{#2}{#4}{#5}{##1}%
  }%
}
\newcommand*{\@DefineTOCEntryBoolOptionMacro}[4]{%
  \@ifundefined{if#2\scr@dte@current#3}{%
    \expandafter\newif\csname if#2\scr@dte@current#3\endcsname
  }{}%
  \FamilySetBool{KOMAarg}{#1}{#2\scr@dte@current#3}{#4}%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@DefineTOCEntryBoolOptionMacro
% \end{macro}^^A \@DefineTOCEntryBoolOptionWithDefault
% \end{macro}^^A \@DefineTOCEntryBoolOptionWithoutDefault
% \end{macro}^^A \DefineTOCEntryBoolOption
%
% \begin{macro}{\DefineTOCEntryCommandOption}
%   \changes{v3.20}{2015/11/17}{neu}
% Verwendet \cs{DefineTOCEntryOption}, um eine Option zu definieren, die ein
% Macro definiert. Es gibt folgende Parameter:
% \begin{description}
% \item[\marg{Stil}: \meta{String},] Name des Eintragsstils
% \item[\marg{Option}: \meta{String},] Name der Option
% \item[\oarg{Wert}:] der Säumniswert der Option
% \item[\marg{Prefix}: \meta{String},] Präfix des zu definierenden Makros
% \item[\marg{Postfix}: \meta{String},] Postfix des zu definierenden Makros
% \item[\marg{Erklärung}: \meta{String},] Erklärung der Option
% \item[\oarg{Init}: \meta{Code},] Initialisierung der Option
% \end{description}
% Zwischen Prefix und Postfix wird bei der späteren, tatsächlichen Definition
% automatisch \cs{scr@dte@current} eingefügt.
% \begin{macro}{\@DefineTOCEntryCommandOptionWithoutDefault}
%   \changes{v3.20}{2015/11/12}{neu (intern)}
% \begin{macro}{\@DefineTOCEntryCommandOptionWithDefault}
%   \changes{v3.20}{2015/11/12}{neu (intern)}
% \begin{macro}{\@DefineTOCEntryCommandOptionMacro}
%   \changes{v3.20}{2015/11/12}{neu (intern)}
% Da mit einem optionalen Argument an Position 3 gearbeitet wird, werden drei
% Hilfsmakros benötigt.
%    \begin{macrocode}
%<*body>
\newcommand*{\DefineTOCEntryCommandOption}[2]{%
  \@ifnextchar [%]
    {\@DefineTOCEntryCommandOptionWithDefault{#1}{#2}}
    {\@DefineTOCEntryCommandOptionWithoutDefault{#1}{#2}}%
}
\newcommand*{\@DefineTOCEntryCommandOptionWithoutDefault}[5]{%
  \TOCStyleNeedsCommandByOption{#1}{#3}{#4}{#2}{#5}%
  \DefineTOCEntryOption{#1}{#2}{%
    \@DefineTOCEntryCommandOptionMacro{#2}{#3}{#4}{##1}%
  }%
}
\newcommand*{\@DefineTOCEntryCommandOptionWithDefault}{}
\def\@DefineTOCEntryCommandOptionWithDefault#1#2[#3]#4#5#6{%
  \TOCStyleNeedsCommandByOption{#1}{#4}{#5}{#2}{#6}%
  \DefineTOCEntryOption{#1}{#2}[{#3}]{%
    \@DefineTOCEntryCommandOptionMacro{#2}{#4}{#5}{##1}%
  }%
}
\newcommand*{\@DefineTOCEntryCommandOptionMacro}[4]{%
  \@namedef{#2\scr@dte@current#3}{#4}%
  \FamilyKeyStateProcessed
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@DefineTOCEntryCommandOptionMacro
% \end{macro}^^A \@DefineTOCEntryCommandOptionWithDefault
% \end{macro}^^A \@DefineTOCEntryCommandOptionWithoutDefault
% \end{macro}^^A \DefineTOCEntryCommandOption
%
% \begin{macro}{\TOCStyleNeedsCommandByOption}
%   \changes{v3.20}{2015/11/12}{neu}
% Fügt einen oder mehrere Befehle der Liste der benötigten Befehle hinzu.
% \begin{description}
% \item[\marg{Stil}:] Der Stil \meta{string}, der die Befehle benötigt.
% \item[\marg{Präfix}:] Präfix \meta{string} des benötigten Befehls.
% \item[\marg{Postfix}:] Postfix \meta{string} des benötigten Befehls.
% \item[\marg{Option}:] Die Option \meta{string}, über die dieser Befehl
%   definiert wird.
% \item[\marg{Erklärung}:] Bedeutung \meta{string} des Befehls.
% \end{description}
% Zwischen Präfix und Postfix wird dann automatisch der Name der
% Gliederungsebene eingefügt.
%    \begin{macrocode}
%<*body>
\newcommand*{\TOCStyleNeedsCommandByOption}[5]{%
  \expandafter\providecommand\expandafter*\csname scr@dte@#1@needs\endcsname{}%
  \expandafter\l@addto@macro\csname scr@dte@#1@needs\endcsname{%
    \do{#2}{#3}{#4}{#5}%
  }%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \TOCStyleNeedsCommandByOption
%
% \begin{macro}{\TOCStyleInitCode}
%   \changes{v3.20}{2015/11/19}{neu}
% Führt Befehle aus, bevor ein Verzeichnisbefehl in diesem Stil definiert wird
% und noch bevor die \emph{needs}-Liste abgearbeitet wird. Argumente sind:
% \begin{description}
% \item[\marg{Stil}:] Der Stil \meta{string} für den die Initialisierung
%   erfolgen soll.
% \item[\marg{Code}:] Wird zwecks Initialisierung ausgeführt. Innerhalb dieses
%   Codes ist \texttt{\#1} der Name der Verzeichnisebene.
% \end{description}
%    \begin{macrocode}
%<*body>
\newcommand{\TOCStyleInitCode}[2]{%
  \expandafter\providecommand\expandafter*%
  \csname scr@dte@#1@init\endcsname[1]{}%
  \expandafter\l@addto@macro@a\csname scr@dte@#1@init\endcsname{#2}%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \TOCStyleInitCode
%
% \begin{macro}{\DeclareTOCStyleEntry}
%   \changes{v3.20}{2015/11/13}{neu}
% Diese Anweisung definiert einen Verzeichniseintragsbefehl. Dabei wird auch
% geprüft, ob all benötigten Befehle definiert sind. Falls das nicht der Fall
% ist, wird der Verzeichniseintragsbefehl nicht definiert, sondern ein Fehler
% gemeldet. Für die Definition werden folgende Argumente verwendet.
% \begin{description}
% \item[\oarg{Optionen}:] Komma separierte Liste von Optionen für die
%   Definition des Eintrags.
% \item[\marg{Stil}:] Der Stil \meta{string}, in dem der Verzeichniseintrag
%   sein soll.
% \item[\marg{Gliederungsebene}:] Der Name \meta{string} der Gliederungsebene
%   für die ein Verzeichniseintrag definiert werden soll.
% \end{description}
% Es wird außerdem eine Anweisung \cs{scr@dte@def@l@\meta{Stil}} benötigt,
% über die dann die eigentliche Definition der Eintragsanweisung
% erfolgt. Diese hat genau ein Argument: \meta{Gliederungsebene}.
%    \begin{macrocode}
%<*body>
\newcommand*{\DeclareTOCStyleEntry}[3][]{%
  \scr@ifundefinedorrelax{scr@dte@def@l@#2}{%
    \ClassError{\KOMAClassName}{toc entry style `#2' undefined}{%
      Somebody told me to define toc entry `#3' with style `#2',\MessageBreak
      but I do not know style `#2'.\MessageBreak
      You should first define the style then define the entry.\MessageBreak
      If you'll continue, I'll ignore the command. This could result
      in\MessageBreak
      further error messages.%
    }%
  }{%
    \IfArgIsEmpty{#1}{}{%
      \def\scr@dte@current{#3}%
      \csname scr@dte@#2@defopts\endcsname
      \FamilyBoolKey[.dte]{KOMAarg}{expandtopt}{scr@dte@expandtopt}%
      \scr@dte@expandtoptfalse
      \FamilyExecuteOptions[.dte]{KOMAarg}{#1}%
      \RelaxFamilyKey[.dte]{KOMAarg}{expandtopt}%
      \csname scr@dte@#2@relaxopts\endcsname
      \let\scr@dte@current\relax
    }%
    \scr@ifundefinedorrelax{#3tocdepth}{%
      \scr@ifundefinedorrelax{#3numdepth}{}{%
        \expandafter\let\csname #3tocdepth\expanafter\endcsname
        \csname #3numdepth\endcsname
      }%
    }{}%
    \scr@ifundefinedorrelax{scr@dte@#2@init}{}{%
      \@nameuse{scr@dte@#2@init}{#3}%
    }
    \begingroup
      \aftergroup\@tempswatrue
      \def\do##1##2##3##4{%
        \scr@ifundefinedorrelax{##1#3##2}{%
          \ClassError{\KOMAClassName}{toc style `#2' needs ##4}{%
            Usually the ##4 is defined using option `##3'.\MessageBreak
            In some cases it may be set defining command
            `\expandafter\string\csname ##1#3##2\endcsname'.\MessageBreak
            If you'll continue, I'll ignore the command. This could result
            in\MessageBreak
            further error messages.%
          }%
          \aftergroup\@tempswafalse
        }{}%
      }%
      \do{}{tocdepth}{level}{toc style level}%
      \@nameuse{scr@dte@#2@needs}%
    \endgroup
    \if@tempswa
      \@nameuse{scr@dte@def@l@#2}{#3}%
    \fi
  }%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \DeclareTOCStyleEntry
%
% \begin{macro}{\DeclareTOCEntryStyle}
%   \changes{v3.20}{2015/11/17}{neu}
% \begin{macro}{\@DeclareTOCEntryStyle}
%   \changes{v3.20}{2015/11/17}{neu (intern)}
% Über diese Anweisung wir ein neuer Stil für TOC-Einträge definiert. Ein Stil
% besteht aus:
% \begin{description}
% \item[\marg{Stil}:] Der Stil \meta{string}, der definiert werden soll.
% \item[\oarg{Optionendeklaration}:] Eine Komma separierte Liste von
%   Optionendeklarationen für diesen Stil. Zur Form dieser Deklarationen siehe
%   unten.
% \item[\marg{Verzeichnisbefehlsdefinition}:] Dies ist der Körper der
% Definition des \cs{l@\dots}-Befehls, der verwendet werden soll. Dabei ist
% \texttt{\#1} der Name der Verzeichnissebene und \texttt{\#\#1} und
% \texttt{\#\#2} sind die beiden Argumente des \cs{l@dots}-Befehls.
% \item[\oarg{Initialisierungscode}:] Dieser Code wird bei der Definition
%   eines Verzeichnisbefehls noch vor der Abarbeitung der \emph{needs}-Liste
%   ausgeführt. Wichtig ist, dass dieser Code erst nach dem
%   Initialisierungscode aus den Optionendeklarationen ausgeführt wird.
% \end{description}
% Unabhängig davon, ob eine \meta{Optionendeklaration} angegeben ist oder
% nicht, wird immer eine Option \texttt{level} definiert, über die die
% Verzeichnisebene einen nummerischen Wert erhält.
%    \begin{macrocode}
%<*body>
\newcommand*{\DeclareTOCEntryStyle}[1]{%
  \@ifnextchar [%]
    {\@DeclareTOCEntryStyle{#1}}%
    {\@DeclareTOCEntryStyle{#1}[]}%
}
\newcommand{\@DeclareTOCEntryStyle}{}
\long\def\@DeclareTOCEntryStyle#1[#2]#3{%
  \@namedef{scr@dte@def@l@#1}##1{%
    \@namedef{l@##1}####1####2{%
      #3%
    }%
  }%
  \DefineTOCEntryNumberOption{#1}{level}{}{tocdepth}{toc entry level}%
  \IfArgIsEmpty{#2}{}{%
    \@for\reserved@a:=#2\do{%
      \ifx\reserved@a\@empty\else
        \def\reserved@b{\scr@dte@define@option{#1}}%
        \expandafter\reserved@b\reserved@a
        \@empty\@empty\@empty\@empty\@empty\@empty\@empty\@empty\@empty\@nil
      \fi
    }%
  }%
  \@ifnextchar [%]
    {\scr@dte@add@optional@initcode{#1}}%
    {}%
}
%    \end{macrocode}
% \begin{macro}{\scr@dte@define@option}
%   \changes{v3.20}{2015/11/17}{neu (intern)}
% \begin{macro}{\scr@dte@define@option@withoutdefault}
%   \changes{v3.20}{2015/11/17}{neu (intern)}
% \begin{macro}{\scr@dte@define@option@withdefault}
%   \changes{v3.20}{2015/11/17}{neu (intern)}
% Über diese Anweisungen werden die Optionen tatsächlich definiert. Sie haben
% mindestens drei und maximal sieben Argumente. Das erste ist dabei immer der
% Stil. Das dritte ist die Option. Das zweite gibt über einen einzelnen
% Buchstaben an, wie die übrigen Argumente zu Optionen werden. Derzeit
% definiert sind:
% \begin{description}
% \item[\texttt{b}:] Es handelt sich um eine Boolsche-Option. Argument 4 ist
%   optional und gibt den Säumniswert an. Argument 5 ist ein Befehlspräfix,
%   Argument 6 ein Befehlspostfix und Argument 7 ist die Optionenbeschreibung
%   für Fehlermeldungen. Alle weiteren Argumente werden ignoriert. Ist kein
%   optionales Argument angegeben, so wird \texttt{true} als Default gesetzt.
% \item[\texttt{c}:] Es handelt sich um eine Befehls- oder
%   String-Option. Argument 4 ist optional und gibt den Säumniswert
%   an. Argument 5 ist ein Befehlspräfix, Argument 6 ein Befehlspostfix und
%   Argument 7 ist die Optionenbeschreibung für Fehlermeldungen. Alle weiteren
%   Argumente werden ignoriert.
% \item[\texttt{l}:] Es handelt sich um eine Längen-Option. Argument 4 ist
%   optional und gibt den Säumniswert an. Argument 5 ist ein Befehlspräfix,
%   Argument 6 ein Befehlspostfix und Argument 7 ist die Optionenbeschreibung
%   für Fehlermeldungen. Alle weiteren Argumente werden ignoriert.
% \item[\texttt{n}:] Es handelt sich um eine Nummern-Option. Argument 4 ist
%   optional und gibt den Säumniswert an. Argument 5 ist ein Befehlspräfix,
%   Argument 6 ein Befehlspostfix und Argument 7 ist die Optionenbeschreibung
%   für Fehlermeldungen. Alle weiteren Argumente werden ignoriert.
% \end{description}
% Alle haben als weiteres optionales Argument die Möglickeit, einen
% Initialisierungscode mit anzugeben.
% Wichtig ist, dass alle optionalen Argumente lediglich am \texttt{[} davor
% erkannt werden. Es gibt kein \texttt{]} am Ende. Korrekte Deklarationen
% wären also beispielsweise:
%  |c{test}[{genau}{scr@dte@}{@test}{test entry},%|
% wobei |{genau}| das optionale Argument wäre.
% Wichtig ist außerdem, dass derzeit keine Leerzeichen aus der Liste
% eliminiert werden. Korrekte Kommentierung ist also wichtig. Komplett leere
% Elemente werden allerdings ignoriert.
%    \begin{macrocode}
\newcommand*{\scr@dte@define@option}[3]{%
  \@ifnextchar [%]
    {\scr@dte@define@option@withdefault{#1}{#2}{#3}}%
    {\scr@dte@define@option@withoutdefault{#1}{#2}{#3}}%
}
\def\scr@dte@define@option@withoutdefault#1#2#3#4#5#6#7#8#9{%
  \IfArgIsEmpty{#3}{%
    \ClassError{\KOMAClassName}{option needs name}{%
      Definition of toc entry style `#1' has an empty option
      name,\MessageBreak
      but toc entry style options must have a name.%
    }%
  }{%
    \IfArgIsEmpty{#6}{%
      \ClassWarning{\KOMAClassName}{%
        Definition of toc entry style option `#3'\MessageBreak
        has an empty description.\MessageBreak
        This could result in strange error messages.\MessageBreak
        Please add some descriptive words%
      }%
    }{}%
    \IfArgIsEmpty{#4#5}{%
      \ClassError{\KOMAClassName}{option needs either prefix or postfix}{%
        Definition of toc entry style option `#3' has an empty\MessageBreak
        command name prefix and an empty command name postfix.\MessageBreak
        At least one of these must not be empty.%
      }%
    }{%
      \if #2l%
        \if #7[%]
          \DefineTOCEntryLengthOption{#1}{#3}{#4}{#5}{#6}[{#8}]%
        \else
          \DefineTOCEntryLengthOption{#1}{#3}{#4}{#5}{#6}\relax
        \fi
      \else
        \if #2n%
          \if #7[%]
            \DefineTOCEntryNumberOption{#1}{#3}{#4}{#5}{#6}[{#8}]%
          \else
            \DefineTOCEntryNumberOption{#1}{#3}{#4}{#5}{#6}\relax
          \fi
        \else
          \if #2b%
            \if #7[%]
              \DefineTOCEntryBoolOption{#1}{#3}[true]{#4}{#5}{#6}[{#8}]%
            \else
              \DefineTOCEntryBoolOption{#1}{#3}[true]{#4}{#5}{#6}\relax
            \fi
          \else
            \if #2c%
              \if #7[%]
                \DefineTOCEntryCommandOption{#1}{#3}{#4}{#5}{#6}[{#8}]%
              \else
                \DefineTOCEntryCommandOption{#1}{#3}{#4}{#5}{#6}\relax
              \fi
            \else
              \ClassError{\KOMAClassName}{%
                unknown toc entry style option type}{%
                Following types are valid:\MessageBreak
                \space b: boolean parameter to be stored as
                \expandafter\string\csname if\endcsname...\MessageBreak
                \space c: code parameter to be stored in a macro\MessageBreak
                \space l: length parameter to be stored in a macro\MessageBreak
                \space n: number parameter to be stored in a macro\MessageBreak
                But not `\detokenize{#2}'.%
              }%
            \fi
          \fi
        \fi
      \fi
    }%
  }%
  \scr@dte@gobble@till@nil
}
\def\scr@dte@define@option@withdefault#1#2#3[#4#5#6#7#8#9{%
  \typeout{TRACE: \string\scr@dte@define@option@withdefault}%
  \IfArgIsEmpty{#3}{%
    \ClassError{\KOMAClassName}{option needs name}{%
      Definition of toc entry style `#1' has an empty option
      name,\MessageBreak
      but toc entry style options must have a name.%
    }%
  }{%
    \IfArgIsEmpty{#7}{%
      \ClassWarning{\KOMAClassName}{%
        Definition of toc entry style option `#3'\MessageBreak
        has an empty description.\MessageBreak
        This could result in strange error messages.\MessageBreak
        Please add some descriptive words%
      }%
    }{}%
    \IfArgIsEmpty{#5#6}{%
      \ClassError{\KOMAClassName}{option needs either prefix or postfix}{%
        Definition of toc entry style option `#3' has an empty\MessageBreak
        command name prefix and an empty command name postfix.\MessageBreak
        At least one of these must not be empty.%
      }%
    }{%
      \if #2l%
        \if #8[%]
          \DefineTOCEntryLengthOption{#1}{#3}[{#4}]{#5}{#6}{#7}[{#9}]%
        \else
          \DefineTOCEntryLengthOption{#1}{#3}[{#4}]{#5}{#6}{#7}\relax
        \fi
      \else
        \if #2n%
          \if #8[%]
            \DefineTOCEntryNumberOption{#1}{#3}[{#4}]{#5}{#6}{#7}[{#9}]%
          \else
            \DefineTOCEntryNumberOption{#1}{#3}[{#4}]{#5}{#6}{#7}\relax
          \fi
        \else
          \if #2b%
            \if #8[%]
              \DefineTOCEntryBoolOption{#1}{#3}[{#4}]{#5}{#6}{#7}[{#9}]%
            \else
              \DefineTOCEntryBoolOption{#1}{#3}[{#4}]{#5}{#6}{#7}\relax
            \fi
          \else
            \if #2c%
              \if #8[%]
                 \DefineTOCEntryCommandOption{#1}{#3}[{#4}]{#5}{#6}{#7}[{#9}]%
              \else
                \DefineTOCEntryCommandOption{#1}{#3}[{#4}]{#5}{#6}{#7}\relax
              \fi
            \else
              \ClassError{\KOMAClassName}{%
                unknown toc entry style option type}{%
                Following types are valid:\MessageBreak
                \space l: length parameter to be stored in a macro\MessageBreak
                \space n: number parameter to be stored in a macro\MessageBreak
                But not `\detokenize{#2}'.%
              }%
            \fi
          \fi
        \fi
      \fi
    }%
  }%
  \scr@dte@gobble@till@nil
}
\newcommand*{\scr@dte@gobble@till@nil}{}
\def\scr@dte@gobble@till@nil#1\@nil{}
%</body>
%    \end{macrocode}
% \end{macro}^^A \scr@dte@define@option@withoutdefault
% \end{macro}^^A \scr@dte@define@option@withdefault
% \end{macro}^^A \scr@dte@define@option
% \end{macro}^^A \@DeclareTOCEntryStyle
% \end{macro}^^A \DeclareTOCEntryStyle
%
% \subsection{Vorgefertigte Verzeichniseintragsstile}
%
% Hier wird quasi an Beispielen gezeigt, wie man Verzeichniseintragsstile
% definieren kann. Einige dieser Stile sind sehr grundlegend. Andere sind
% stellen Erweiterungen der grundlegenden Stile dar. Die Stile können über
% mehrere \texttt{docstrip}-Durchgänge einzeln in den Quelltext gelangen.
%
% \iffalse
%<*style>
% \fi
%
% \begin{macro}{\scr@dte@def@l@gobble}
%   \changes{v3.20}{2015/11/20}{neuer Verzeichniseintragsstil
%     \texttt{gobble}}^^A
% Der aller einfachste Verzeichniseintragsstil ist \texttt{gobble}. Er nimmt
% die beiden Argumente für den Verzeichniseintrag und die Seitenzahl und
% vergisst sie unabhängig von der Ebene des Eintrags einfach. Daher benötigt
% dieser Stil auch keinerlei Optionen oder Initialisierung.
%    \begin{macrocode}
%<*gobble>
%%% - generation of style gobble (run: style,gobble)
\DeclareTOCEntryStyle{gobble}{}%
%</gobble>
%    \end{macrocode}
% \end{macro}^^A \scr@dte@def@l@gobble
%
% \begin{macro}{\scr@dte@def@l@dottedtocline}
%   \changes{v3.20}{2015/11/20}{neuer Verzeichniseintragsstil
%     \texttt{dottedtocline}}^^A
% Der einfachste echte Verzeichniseintragsstil ist
% \texttt{dottedtocline}. Dieser verwendet einfach nur die
% \LaTeX-Kern-Anweisung \cs{dottedtocline}. Für \KOMAScript{} selbst sollte
% man dieses Stil nicht verwenden. Man kann ihn aber beispielsweise mit den
% Standardklassen verwenden, wenn man kompatibel bleiben will. Dieser benötigt
% jedoch bereits Angaben bezüglich der Nummernbreite und des
% Eintragseinzugs. Der ohnehin immer definierte Level wird ebenfalls
% ausgewertet.
% \begin{macro}{\scr@dte@def@l@undottedtocline}
%   \changes{v3.20}{2015/11/20}{neuer Verzeichniseintragsstil
%     \texttt{undottedtocline}}^^A
% Im Unterschied dazu entspricht der Verzeichniseintragsstil
% \texttt{undottedtocline} dem der \texttt{chapter}-Ebene der
% Standardklassen. Im Unterschied zu diesen wird jedoch ein Eintragseinzug
% unterstützt.
% \begin{macro}{\scr@dte@def@l@largetocline}
%   \changes{v3.20}{2015/11/20}{neuer Verzeichniseintragsstil
%     \texttt{largetocline}}^^A
% Im Unterschied dazu entspricht der Verzeichniseintragsstil
% \texttt{largetocline} dem der \texttt{part}-Ebene der Standardklassen. Im
% Unterschied zu diesen wird jedoch ein Eintragseinzug unterstützt. Eine
% Nummernbreite gibt es hingegen nicht. Stattdessen werden die Einträge nicht
% hängend gesetzt.
%    \begin{macrocode}
%<*dottedtocline|undottedtocline|largetocline>
%<*dottedtocline>
%%% - generation of style dottedtocline (run: style,dottedtocline)
\DeclareTOCEntryStyle{dottedtocline}[%
%</dottedtocline>
%<*undottedtocline>
%%% - generation of style dottedtocline (run: style,undottedtocline)
\DeclareTOCEntryStyle{undottedtocline}[%
%</undottedtocline>
%<*dottedtocline|undottedtocline>
  l{numwidth}{scr@}{@tocnumwidth}{entry number width},%
%</dottedtocline|undottedtocline>
%<*largetocline>
%%% - generation of style largetocline (run: style, largetocline)
\DeclareTOCEntryStyle{largetocline}[%
%</largetocline>
  l{indent}{scr@}{@tocindent}{entry indent},%
]{%
%<*dottedtocline>
  \@dottedtocline{\@nameuse{#1tocdepth}}{\@nameuse{scr@#1@tocindent}}%
                 {\@nameuse{scr@#1@tocnumwidth}}{##1}{##2}%
%</dottedtocline>
%<*undottedtocline|largetocline>
  \ifnum \c@tocdepth >\numexpr \@nameuse{#1tocdepth}-\@ne\relax
%    \end{macrocode}
% An dieser Stelle gibt es einen kleinen Unterschied zwischen der
% \texttt{chapter}-Ebene und der \texttt{section}-Ebene von
% \textsf{article}. Diesen machen wir hier an der nummerischen Ebene fest.
%    \begin{macrocode}
    \ifnum \@nameuse{#1tocdepth}<\@ne
      \scr@ifundefinedorrelax{chapter}{%
        \addpenalty\@secpenalty
%<undottedtocline>        \addvspace{1.0em \@plus\p@}%
%<largetocline>        \addvspace{2.25em \@plus\p@}%
      }{%
        \addpenalty{-\@highpenalty}%
%<undottedtocline>        \vskip 1.0em \@plus\p@
%<largetocline>        \vskip 2.25em \@plus\p@
      }%
    \else
      \addpenalty\@secpenalty
%<undottedtocline>      \addvspace{1.0em \@plus\p@}%
%<largetocline>      \addvspace{2.25em \@plus\p@}%
    \fi
%<undottedtocline>    \setlength\@tempdima{\@nameuse{scr@#1@tocnumwidth}}%
%<largetocline>    \setlength\@tempdima{3em}%
    \begingroup
      \parindent \z@ \rightskip \@pnumwidth
      \parfillskip -\@pnumwidth
%<largetocline>      {%
      \leavevmode 
%<largetocline>      \large
      \bfseries
%<undottedtocline>      \advance\leftskip\@tempdima
      \advance\leftskip\@nameuse{scr@#1@tocindent}%
%<*undottedtocline>
      \hskip -\dimexpr \leftskip-\@nameuse{scr@#1@tocindent}\relax
%</undottedtocline>
      ##1%
%<undottedtocline>      \nobreak
      \hfil \nobreak\hb@xt@\@pnumwidth{\hss ##2}%
%<largetocline>      }
      \par
%<undottedtocline>      \penalty\@highpenalty
%<*largetocline>
      \nobreak
      \ifnum 0=
        \scr@ifundefinedorrelax{chapter}{\if@compatibility 1\else 0\fi}{1}\relax
        \global\@nobreaktrue
        \everypar{\global\@nobreakfalse\everypar{}}%
      \fi
%</largetocline>
    \endgroup
  \fi
%</undottedtocline|largetocline>
}[{%
%    \end{macrocode}
% Die Werte für \texttt{level}, \texttt{indent} und \texttt{numwidth} sind
% entweder bereits bekannt oder werden mit den Werten initialisiert, die auch
% bei den Standardklassen verwendet werden:
%    \begin{macrocode}
  \@ifundefined{#1tocdepth}{%
    \ifstr{#1}{part}{\@namedef{#1tocdepth}{-1}}{%
      \ifstr{#1}{chapter}{\@namedef{#1tocdepth}{0}}{%
        \ifstr{#1}{section}{\@namedef{#1tocdepth}{1}}{%
          \ifstr{#1}{subsection}{\@namedef{#1tocdepth}{2}}{%
            \ifstr{#1}{subsubsection}{\@namedef{#1tocdepth}{3}}{%
              \ifstr{#1}{paragraph}{\@namedef{#1tocdepth}{4}}{%
                \ifstr{#1}{subparagraph}{\@namedef{#1tocdepth}{5}}{%
                  \ifstr{#1}{figure}{\@namedef{#1tocdepth}{1}}{%
                    \ifstr{#1}{table}{\@namedef{#1tocdepth}{1}}{%
%    \end{macrocode}
% Für unbekannte Anweisungen wird vorsichtshalber nichts definiert, sondern
% der Anwender soll das per Option \texttt{level} selbst machen.
%    \begin{macrocode}
                    }%
                  }%
                }%
              }%
            }%
          }%
        }%
      }%
    }%
  }{}%
%    \end{macrocode}
% Die Werte für den Einzug und die Nummernbreite unterscheiden sich je
% nachdem, ob es Kapitel gibt oder nicht. Also wird hier explizit auf das
% Vorhandensein der Anweisung \cs{chapter} getestet, allerdings nicht für
% \texttt{figure} oder \texttt{table}, da diese davon unabhängig sind. Die
% Ebene \texttt{part} wird bei den Standardklassen nicht mit
% \cs{dottedtocline} gesetzt. Auch eine Nummernbreite gibt es
% nicht. Deshalb wird für den Einzug Null festgelegt, die Nummernbreite muss
% der Anwender aber selbst über Option \texttt{numwidth} festlegen. Bei
% Kapiteln ist es etwas anders, da sind beide Werte indirekt festgelegt und
% können daher auch übernommen werden.
%    \begin{macrocode}
  \@ifundefined{scr@#1@tocindent}{%
    \ifstr{#1}{figure}{\@namedef{scr@#1@tocindent}{1.5em}}{%
      \ifstr{#1}{table}{\@namedef{scr@#1@tocindent}{1.5em}}{%
        \ifstr{#1}{part}{\@namedef{scr@#1@tocindent}{0em}}{%
          \ifstr{#1}{chapter}{\@namedef{scr@#1@tocindent}{0em}}{%
          }%
        }%
      }%
    }%
  }{}%
  \@ifundefined{scr@#1@tocindent}{%
    \scr@ifundefinedorrelax{chapter}{%
      \ifstr{#1}{section}{\@namedef{scr@#1@tocindent}{0pt}}{%
        \ifstr{#1}{subsection}{\@namedef{scr@#1@tocindent}{1.5em}}{%
          \ifstr{#1}{subsubsection}{\@namedef{scr@#1@tocindent}{3.8em}}{%
            \ifstr{#1}{paragraph}{\@namedef{scr@#1@tocindent}{7em}}{%
              \ifstr{#1}{subparagraph}{\@namedef{scr@#1@tocindent}{10em}}{%
              }%
            }%
          }%
        }%
      }%
    }{%
      \ifstr{#1}{section}{\@namedef{scr@#1@tocindent}{1.5em}}{%
        \ifstr{#1}{subsection}{\@namedef{scr@#1@tocindent}{3.8em}}{%
          \ifstr{#1}{subsubsection}{\@namedef{scr@#1@tocindent}{7.0em}}{%
            \ifstr{#1}{paragraph}{\@namedef{scr@#1@tocindent}{10em}}{%
              \ifstr{#1}{subparagraph}{\@namedef{scr@#1@tocindent}{12em}}{%
              }%
            }%
          }%
        }%
      }%
    }%
  }{}%
%<*dottedtocline|undottedtocline>
  \@ifundefined{scr@#1@numwidth}{%
    \ifstr{#1}{figure}{\@namedef{scr@#1@numwidth}{2.3em}}{%
      \ifstr{#1}{table}{\@namedef{scr@#1@numwidth}{2.3em}}{%
        \ifstr{#1}{chapter}{\@namedef{scr@#1@numwidth}{1.5em}}{%
        }%
      }%
    }%
  }{}%
  \@ifundefined{scr@#1@numwidth}{%
    \scr@ifundefinedorrelax{chapter}{%
      \ifstr{#1}{section}{\@namedef{scr@#1@numwidth}{1.5em}}{%
        \ifstr{#1}{subsection}{\@namedef{scr@#1@numwidth}{2.3em}}{%
          \ifstr{#1}{subsubsection}{\@namedef{scr@#1@numwidth}{3.2em}}{%
            \ifstr{#1}{paragraph}{\@namedef{scr@#1@numwidth}{4.1em}}{%
              \ifstr{#1}{subparagraph}{\@namedef{scr@#1@numwidth}{5m}}{%
              }%
            }%
          }%
        }%
      }%
    }{%
      \ifstr{#1}{section}{\@namedef{scr@#1@numwidth}{2.3em}}{%
        \ifstr{#1}{subsection}{\@namedef{scr@#1@numwidth}{3.2em}}{%
          \ifstr{#1}{subsubsection}{\@namedef{scr@#1@numwidth}{3.1em}}{%
            \ifstr{#1}{paragraph}{\@namedef{scr@#1@numwidth}{5em}}{%
              \ifstr{#1}{subparagraph}{\@namedef{scr@#1@numwidth}{6m}}{%
              }%
            }%
          }%
        }%
      }%
    }%
  }{}%
%</dottedtocline|undottedtocline>
}]
%</dottedtocline|undottedtocline|largetocline>
%    \end{macrocode}
% \end{macro}^^A \scr@dte@def@l@largetocline
% \end{macro}^^A \scr@dte@def@l@undottedtocline
% \end{macro}^^A \scr@dte@def@l@dottedtocline
%
% \begin{macro}{\scr@dte@def@l@tocline}
%   \changes{v3.20}{2015/11/22}{neuer Verzeichniseintragsstil
%     \texttt{tocline}}^^A
% Das wird der hochflexible Stil für Verzeichniseinträge, die aus einer oder
% mehreren Zeilen bestehen. Dieser wird über diverse Hilfsmakros definiert.
%    \begin{macrocode}
%<*tocline>
%%% - generation of style dottedtocline (run: style,tocline)
\DeclareTOCEntryStyle{tocline}[%
  c{onstarthigherlevel}{scr@dte@}{@LastTOCLevelWasLower}{start higher level
    entry hook},%
  c{onstartsamelevel}{scr@dte@}{@LastTOCLevelWasSame}{start same level entry
    hook},%
  c{onstartlowerlevel}{scr@dte@}{@LastTOCLevelWasHigher}{start lower level
    entry hook},%
  l{beforeskip}{scr@dte@}{@beforeskip}{vertical skip before the entry},%
  l{indent}{scr@}{@tocindent}{entry indent},%
  l{numwidth}{scr@}{@tocnumwidth}{entry number width},%
]{%
  \scr@dte@tocline{#1}{##1}{##2}%
}[{%
%    \end{macrocode}
% Die Ebene kann auf zweierlei Arten automatisch bestimmt werden. Zum einen
% wird für Sub-Ebenen die Elternebene um eins erhöht verwendet, falls die
% Elternebene bereits definiert ist.
%    \begin{macrocode}
  \scr@ifundefinedorrelax{#1tocdepth}{%
    \ifstrstart{#1}{sub}{%
      \scr@ifundefinedorrelax{\scr@dte@nosub{#1}tocdepth}{}{%
        \expandafter\edef\csname #1tocdepth\endcsname{%
          \numexpr \noexpand\@nameuse{\@scr@dte@nosub{#1}tocdepth}+\@ne\relax
        }%
      }%
    }{}%
  }{}%
%    \end{macrocode}
% War der Weg über Elternebenen nicht erfolgreich, so werden Standardwerte
% angenommen, wie sie bei den Standardklassen und bei \KOMAScript{}
% zutreffen.
%    \begin{macrocode}
  \@ifundefined{#1tocdepth}{%
    \ifstr{#1}{part}{\@namedef{#1tocdepth}{-1}}{%
      \ifstr{#1}{chapter}{\@namedef{#1tocdepth}{0}}{%
        \ifstr{#1}{section}{\@namedef{#1tocdepth}{1}}{%
          \ifstr{#1}{subsection}{\@namedef{#1tocdepth}{2}}{%
            \ifstr{#1}{subsubsection}{\@namedef{#1tocdepth}{3}}{%
              \ifstr{#1}{paragraph}{\@namedef{#1tocdepth}{4}}{%
                \ifstr{#1}{subparagraph}{\@namedef{#1tocdepth}{5}}{%
                  \ifstr{#1}{figure}{\@namedef{#1tocdepth}{1}}{%
                    \ifstr{#1}{table}{\@namedef{#1tocdepth}{1}}{%
%    \end{macrocode}
% Für unbekannte Anweisungen wird vorsichtshalber nichts definiert, sondern
% der Anwender soll das per Option \texttt{level} selbst machen.
%    \begin{macrocode}
                    }%
                  }%
                }%
              }%
            }%
          }%
        }%
      }%
    }%
  }{}%
%    \end{macrocode}
% Die Standardeinstellungen für die drei Penalty-Hooks sind einfach die
% Standardanweisungen dafür. Dabei ist das so definiert, dass Änderungen an
% den Standardanweisungen direkte Auswirkungen haben.
%    \begin{macrocode}
  \expandafter\providecommand\expandafter*%
  \csname scr@dte@#1@LastTOCLevelWasLower\endcsname{\LastTOCLevelWasLower}%
  \expandafter\providecommand\expandafter*%
  \csname scr@dte@#1@LastTOCLevelWasSame\endcsname{\LastTOCLevelWasSame}%
  \expandafter\providecommand\expandafter*%
  \csname scr@dte@#1@LastTOCLevelWasHigher\endcsname{\LastTOCLevelWasHigher}%
%    \end{macrocode}
% Die Voreinstellung für den vertikalen Abstand ist Null mit ein klein wenig
% Leim, um den Seitenumbruch zu optimieren. Das genügt bei einer normalen
% A4-Seite aber gerade mal für den Ausgleich einer Zeile.
%    \begin{macrocode}
  \expandafter\providecommand\expandafter*%
  \csname scr@dte@#1@beforeskip\endcsname{\glueexpr \z@ plus .2\p@\relax}%
%    \end{macrocode}
% Der Einzug kann wie der Level aus der Elternebene gebildet.
%    \begin{macrocode}
  \scr@ifundefinedorrelax{scr@#1@tocindent}{%
    \ifstrstart{#1}{sub}{%
      \scr@ifundefinedorrelax{scr@\scr@dte@nosub{#1}@tocindent}{%
        \scr@ifundefinedorrelax{scr@\scr@dte@nosub{#1}@tocnumwidth}{}{%
          \expandafter\edef\csname scr@#1@tocindent\endcsname{%
            \glueexpr \noexpand\@nameuse{scr@\scr@dte@nosub{#1}@tocnumwidth}%
            \relax
          }%
        }%
      }{%
        \scr@ifundefinedorrelax{scr@\scr@dte@nosub{#1}@tocnumwidth}{%
          \expandafter\edef\csname scr@#1@tocindent\endcsname{%
            \glueexpr \noexpand\@nameuse{scr@\scr@dte@nosub{#1}@tocindent}%
            \relax
          }%
        }{%
          \expandafter\edef\csname scr@#1@tocindent\endcsname{%
            \glueexpr \noexpand\@nameuse{scr@\scr@dte@nosub{#1}@tocindent}%
                     +\noexpand\@nameuse{scr@\scr@dte@nosub{#1}@tocnumwidth}%
            \relax
          }%
        }%
      }%
    }{}%
  }{}%
%    \end{macrocode}
% War das nicht erfolgreich, können auch Standardwerte verwendet werden.
%    \begin{macrocode}
  \@ifundefined{scr@#1@tocindent}{%
    \ifstr{#1}{figure}{\@namedef{scr@#1@tocindent}{1.5em}}{%
      \ifstr{#1}{table}{\@namedef{scr@#1@tocindent}{1.5em}}{%
        \ifstr{#1}{part}{\@namedef{scr@#1@tocindent}{0em}}{%
          \ifstr{#1}{chapter}{\@namedef{scr@#1@tocindent}{0em}}{%
          }%
        }%
      }%
    }%
  }{}%
  \@ifundefined{scr@#1@tocindent}{%
    \scr@ifundefinedorrelax{chapter}{%
      \ifstr{#1}{section}{\@namedef{scr@#1@tocindent}{0pt}}{%
        \ifstr{#1}{subsection}{\@namedef{scr@#1@tocindent}{1.5em}}{%
          \ifstr{#1}{subsubsection}{\@namedef{scr@#1@tocindent}{3.8em}}{%
            \ifstr{#1}{paragraph}{\@namedef{scr@#1@tocindent}{7em}}{%
              \ifstr{#1}{subparagraph}{\@namedef{scr@#1@tocindent}{10em}}{%
              }%
            }%
          }%
        }%
      }%
    }{%
      \ifstr{#1}{section}{\@namedef{scr@#1@tocindent}{1.5em}}{%
        \ifstr{#1}{subsection}{\@namedef{scr@#1@tocindent}{3.8em}}{%
          \ifstr{#1}{subsubsection}{\@namedef{scr@#1@tocindent}{7.0em}}{%
            \ifstr{#1}{paragraph}{\@namedef{scr@#1@tocindent}{10em}}{%
              \ifstr{#1}{subparagraph}{\@namedef{scr@#1@tocindent}{12em}}{%
              }%
            }%
          }%
        }%
      }%
    }%
  }{}%
%    \end{macrocode}
% Für die Nummernbreite gibt es ebenfalls beide Wege.
%    \begin{macrocode}
  \scr@ifundefinedorrelax{scr@#1@tocnumwidth}{%
    \ifstrstart{#1}{sub}{%
      \scr@ifundefinedorrelax{scr@\scr@dte@nosub{#1}@tocnumwidth}{}{%
        \expandafter\edef\csname scr@#1@tocnumwidth\endcsname{%
          \glueexpr \noexpand\@nameuse{scr@\scr@dte@nosub{#1}@tocnumwidth}%
                   +.9em%
          \relax
        }%
      }%
    }{}%
  }{}%
  \@ifundefined{scr@#1@numwidth}{%
    \ifstr{#1}{figure}{\@namedef{scr@#1@numwidth}{2.3em}}{%
      \ifstr{#1}{table}{\@namedef{scr@#1@numwidth}{2.3em}}{%
        \ifstr{#1}{chapter}{\@namedef{scr@#1@numwidth}{1.5em}}{%
        }%
      }%
    }%
  }{}%
  \@ifundefined{scr@#1@numwidth}{%
    \scr@ifundefinedorrelax{chapter}{%
      \ifstr{#1}{section}{\@namedef{scr@#1@numwidth}{1.5em}}{%
        \ifstr{#1}{subsection}{\@namedef{scr@#1@numwidth}{2.3em}}{%
          \ifstr{#1}{subsubsection}{\@namedef{scr@#1@numwidth}{3.2em}}{%
            \ifstr{#1}{paragraph}{\@namedef{scr@#1@numwidth}{4.1em}}{%
              \ifstr{#1}{subparagraph}{\@namedef{scr@#1@numwidth}{5m}}{%
              }%
            }%
          }%
        }%
      }%
    }{%
      \ifstr{#1}{section}{\@namedef{scr@#1@numwidth}{2.3em}}{%
        \ifstr{#1}{subsection}{\@namedef{scr@#1@numwidth}{3.2em}}{%
          \ifstr{#1}{subsubsection}{\@namedef{scr@#1@numwidth}{3.1em}}{%
            \ifstr{#1}{paragraph}{\@namedef{scr@#1@numwidth}{5em}}{%
              \ifstr{#1}{subparagraph}{\@namedef{scr@#1@numwidth}{6m}}{%
              }%
            }%
          }%
        }%
      }%
    }%
  }{}%
}]
%    \end{macrocode}
% \begin{macro}{\scr@dte@nosub}
%   \changes{v3.20}{2015/11/23}{neu (intern)}
% \begin{macro}{\@scr@dte@nosub}
%   \changes{v3.20}{2015/11/23}{neu (intern)}
% Über diese Hilfsmacros werden die Buchstaben \texttt{sub} am Anfang des
% Arguments entfernt. Stehen diese gar nicht am Anfang, so wird ein Fehler
% wegen falscher Verwendung von \cs{@scr@de@nosub} gemeldet.
%    \begin{macrocode}
\newcommand*{\scr@dte@nosub}[1]{\@scr@dte@nosub #1\relax}
\newcommand*{\@scr@dte@nosub}{}
\def\@scr@dte@nosub sub#1\relax{#1}
%    \end{macrocode}
% \end{macro}^^A \@scr@dte@nosub
% \end{macro}^^A \scr@dte@nosub
% \begin{macro}{\scr@dte@tocline}
%   \changes{v3.20}{2015/11/22}{neu (intern)}
% In gewisser Weise entspricht diese Anweisung der \LaTeX-Kern-Anweisung
% \cs{dottedtocline}. Allerdings werden hier vielfältige
% Eingriffsmöglichkeiten untersützt, die jeweils durch Optionen gesteuert
% werden können. Daher hat der Befehl auch nur drei Argumente:
% \begin{description}
% \item[\marg{Ebene}:] Der Name \meta{string} der Verzeichnisebene.
% \item[\marg{Eintrag}:] Der Verzeichniseintrag \meta{string}.
% \item[\marg{Seite}:] Die Seitenzahl \meta{string} des Verzeichniseintrags.
% \end{description}
%    \begin{macrocode}
\newcommand*{\scr@dte@tocline}[3]{%
  \ifnum \@nameuse{#1tocdepth}>\c@tocdepth
  \else
    \DependOnPenaltyAndTOCLevel{#1}%
    \vskip \@nameuse{scr@dte@#1@beforeskip}\relax
    {%
      \leftskip \@nameuse{scr@#1@tocindent}\relax 
      \rightskip \@tocrmarg 
      \parfillskip -\rightskip
      \parindent \@nameuse{scr@#1@tocindent}\relax
      \@afterindenttrue
      \interlinepenalty\@M
      \leavevmode
      \@tempdima \@nameuse{scr@#1@tocnumwidth}\relax
      \advance\leftskip \@tempdima 
      \null\nobreak\hskip -\leftskip
      {#2}\nobreak
      \leaders\hbox{$\m@th
        \mkern \@dotsep mu\hbox{.}\mkern \@dotsep
        mu$}\hfill
      \nobreak
      \hb@xt@\@pnumwidth{\hfil\normalfont \normalcolor #3}%
      \par
    }%
    \SetPenaltyByTOCLevel{#1}%
  \fi
}
%    \end{macrocode}
% \begin{macro}{\DependOnPenaltyAndTOCLevel}
%   \changes{v3.20}{2015/11/23}{neu}
% Führt eine gespeicherte Aktion in Abhängigkeit davon aus, ob der aktuelle
% Penalty-Wert darauf schließen lässt, dass zuvor ein Eintrag mit einem
% höheren, demselben oder einem tieferen Wert für die Ebene erfolgte.
% \begin{macro}{\SetPenaltyByTOCLevel}
%   \changes{v3.20}{2015/11/23}{neu}
% Setze die Strafpunkte für einen Umbruch entsprechend der aktuellen
% Verzeichnisebene.
% \begin{macro}{\LastTOCLevelWasHigher}
%   \changes{v3.20}{2015/11/23}{neu}
% Standardaktion, falls der vorherige Level einen größeren Wert hatte: Umbruch
% erlauben.
% \begin{macro}{\LastTOCLevelWasSame}
%   \changes{v3.20}{2015/11/23}{neu}
% Standardaktion, falls der vorherige Level denselben Wert hatte: Umbruch
% erlauben.
% \begin{macro}{\LastTOCLevelWasLower}
% Standardaktion, falls der vorherige Level einen kleineren Wert hatte:
% Penalty beibehalten und damit den Umbruch verbieten.
%   \changes{v3.20}{2015/11/23}{neu}
%    \begin{macrocode}
\newcommand*{\DependOnPenaltyAndTOCLevel}[1]{%
  \ifnum \lastpenalty<\numexpr 20009-\@nameuse{#1tocdepth}\relax
    \@nameuse{scr@dte@#1@LastTOCLevelWasHigher}%
  \else\ifnum \lastpenalty=\numexpr 20009-\@nameuse{#1tocdepth}\relax
      \@nameuse{scr@dte@#1@LastTOCLevelWasSame}%
    \else
      \@nameuse{scr@dte@#1@LastTOCLevelWasLower}%
    \fi
  \fi
}
\newcommand*{\SetPenaltyByTOCLevel}[1]{%
  \penalty \numexpr 20009-\@nameuse{#1tocdepth}\relax
}
\newcommand*{\LastTOCLevelWasHigher}{\addpenalty{\@lowpenalty}}
\newcommand*{\LastTOCLevelWasSame}{\addpenalty{\@lowpenalty}}
\newcommand*{\LastTOCLevelWasLower}{}
%</tocline>
%    \end{macrocode}
% \end{macro}^^A \SetPenaltyByTOCLevel
% \end{macro}^^A \DependOnPenaltyAndTOCLevel
% \end{macro}^^A \LastTOCLevelWasLower
% \end{macro}^^A \LastTOCLevelWasSame
% \end{macro}^^A \LastTOCLevelWasHigher
% \end{macro}^^A \scr@dte@tocline
% \end{macro}^^A \scr@dte@def@l@tocline
%
%
% \iffalse
%</style>
% \fi
%
% \Finale
%
\endinput
%
% end of file `scrkernel-tocstyle.dtx'
%%% Local Variables:
%%% mode: doctex
%%% coding: iso-latin-1
%%% TeX-master: t
%%% End:
